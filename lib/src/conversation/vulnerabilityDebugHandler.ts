import { Unknown } from '../types';
import { dedent } from 'ts-dedent';

// interface DebugCodeVulnerabilityDetails {
//   type: string;
//   description: string;
//   ui_type: string;
//   ui_description: string;
// }
//
// interface DebugCodeVulnerability {
//   id: number;
//   start_offset: number;
//   stop_offset: number;
//   type: string;
//   details: DebugCodeVulnerabilityDetails;
// }

const DebugCodeVulnerability: Unknown.Annotation = {
  id: 0,
  start_offset: 0,
  stop_offset: 0,
  type: 'code_vulnerability',
  details: {
    type: 'server-side-unvalidated-url-redirection',
    description: 'Allows a URL to be redirected to a different URL that is specified by an external user.',
    ui_type: 'test',
    ui_description: 'test',
  },
};

const DebugCodeVulnerabilityParagraphMessage = dedent`
    Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna
    aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.
`;

const DebugCodeVulnerabilityCodeBlock = dedent`
    \`\`\`kotlin
    fun main() {
        println("Hello, World!")
    }
    \`\`\`
`;

const DebugCodeVulnerabilityHelpText = dedent`
    ### Inputs

    \`p\` - paragraph message

    \`c\` - code block

    \`<number>\` - number of vulnerabilities, must be at the end of the string (applies to all code blocks)

    ### Examples

    \`/debug.vulnerability\` - 1 paragraph followed by 1 code block with 1 vulnerability

    \`/debug.vulnerability pcc2\` - 1 paragraph followed by 2 code blocks with 2 vulnerabilities each

    \`/debug.vulnerability cpc3\` - 1 code block followed by 1 paragraph followed by 1 code block--each code block has 3 vulnerabilities
`;

const MarkdownNewLine = '\n\n';

const DebugCodeVulnerabilityDefaultReply =
  DebugCodeVulnerabilityParagraphMessage + MarkdownNewLine + DebugCodeVulnerabilityCodeBlock;

function parseVulnerabilitiesInstructions(input: string): { reply: string; vulnerabilities: number } {
  let vulnerabilities = 1;

  if (input.length === 0) return { reply: DebugCodeVulnerabilityDefaultReply, vulnerabilities };
  if (input === '0') return { reply: DebugCodeVulnerabilityDefaultReply, vulnerabilities: 0 };
  if (input === 'help') return { reply: DebugCodeVulnerabilityHelpText, vulnerabilities };

  let lastChar = input.slice(-1);
  if (!isNaN(Number(lastChar))) {
    vulnerabilities = Number(lastChar);
    input = input.slice(0, -1);
  }

  let reply = '';
  for (let char of input) {
    if (char === 'p') {
      reply += DebugCodeVulnerabilityParagraphMessage + MarkdownNewLine;
    } else if (char === 'c') {
      reply += DebugCodeVulnerabilityCodeBlock + MarkdownNewLine;
    }
  }

  return { reply: reply.trimEnd(), vulnerabilities };
}

export { DebugCodeVulnerability, parseVulnerabilitiesInstructions };
